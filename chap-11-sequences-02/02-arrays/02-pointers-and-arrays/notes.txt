An array name used in C++ source code references a location in memory, the address of 
the first element (element at index 0) in the array. In this way an array name is 
similar to a constant pointer. Because of this, we can treat in some ways an array identifier
like a pointer. Similarly, we can direct a pointer to point to an array, and then treat 
the pointer itself as if it were an array.

Example (pointerprint.cpp)

    #include <iostream>

    using std::cout;

    int main()
    {
        cout << '\n';

        int a[] = {2, 4, 6, 8, 10, 12};
        // int *p = &a[0];
        int *p = a; // a is itself a reference to the array's location in memory

        // Print out the contents of the array
        int size = (sizeof a) / (sizeof a[0]);
        for (int i = 0; i < size; i++)
        {
            cout << *p << " "; // Print the element p points to
            p++; // Increment p so it points to the next element
        }
        cout << '\n';
    } 

The statement
    
    p = &a[0];

sets p to point to the first element of array a. A shorter way to accomplish the same thing is

    p = a;

since a is itself a reference to the array’s location in memory. This assignment statement clearly demonstrates
the association between array variables and pointer variables. Note that the opposite assignment
(a = p) is impossible, because array a declared as above may not appear by itself on the left side of the
assignment operator.

Pointer variables can participate in addition and subtraction expressions. The statement
    
    p++;

changes the address stored in p so subsequently the pointer will point to the next integer position in memory.
If p is assigned to array a, incrementing p redirects it to point to a’s next element.    

The expression p[0] is another way to write *p
So the array indexing operator ([]) can be used with pointers
The expression p[5] represents the element at index 5 within 
the array pointed by p

*** Note
If pointer p points to an array, the element at index i can be accessed as either p[i] or *(p + i).
The expression *(p + i) dereferences the address that is i positions away from the address referenced
by p.

Example 1:
    // Print out the contents of the array
    p = a;
    for (int i = 0; i < size; i++)
    {
        cout << p[i] << " ";
    }
    cout << '\n';

Example 2:
    // Print out the contents of the array
    p = a;
    for (int i = 0; i < size; i++)
    {
        cout << *(p + i) << " ";
    }
    cout << '\n';

*** Note
Sometimes pointer notation is used to represent an array parameter to a function. 
The array print function that begins:

    void print_array(const int a[], int size)

could instead be written:
    void print_array(const int *a, int size)     

where a is a pointer to an array. The compiler treats the two forms identically 
in the machine language it produces.    

*** Note
Each byte in memory has a unique numeric address. Since most C++ types require more than one byte of storage, incrementing
a pointer by 1 does not simply add 1 to the address it holds. The amount added depends on the type of the pointer; for example, on
systems using 32-bit (4 byte) integers, adding 1 to an integer pointer variable increments its address by 4, not 1. The compiler knows
the type of the pointer variable because programmers must declare all variables. The compiler, therefore, can automatically adjust the
arithmetic to work properly. If a pointer points to memory within an array and is of the same type as the array, incrementing the pointer
correctly repositions the pointer to point to the next element in the array.